<?php

namespace famima65536\lwe\entity;

use pocketmine\block\Transparent;
use pocketmine\entity\Entity;
use pocketmine\entity\Living;
use pocketmine\entity\Location;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\player\Player;
use pocketmine\world\format\Chunk;

abstract class LightweightLiving extends Living {

	# code for search
	protected int $targetSearchDistance = 30;
	private int $searchCooldown = 100;
	protected int $searchTime = 0;

	protected ?Entity $target = null;

	protected float $boundingRadius = 0.5;
	protected float $attackDistance = 1;

	protected int $actionAttackTime = 0;

	protected $jumpVelocity = 0.5;

	protected array $path = [];
	protected ?Vector3 $currentTargetLocation = null;

	public function __construct(Location $location, ?CompoundTag $nbt = null){
		parent::__construct($location, $nbt);
		$this->moveSpeedAttr->setValue(0.3);
	}


	public function searchTarget(): void{
		$currentTarget = $this->getTargetEntity();
		if(($currentTarget === null or $currentTarget->closed) and $this->searchTime === 0){
			$this->searchTime = $this->searchCooldown;
			$this->realSearchTarget();
		}
	}

	private function realSearchTarget(): void{
		$target = $this->getWorld()->getNearestEntity($this->location, $this->targetSearchDistance, Player::class);
		$this->setTarget($target);
	}

	public function onUpdate(int $currentTick): bool{
		$update = parent::onUpdate($currentTick);
		$this->searchTarget();
		$targetEntity = $this->target;
		if($targetEntity === null or $targetEntity->closed){
			$this->setTarget(null);
			return $update;
		}
		$this->lookAt($this->target->getLocation()->add(0, 0.7, 0));

		if($this->attackTime > 0){
			return $update;
		}
		$vectorToTarget = $targetEntity->getPosition()->subtractVector($this->location);

		$vectorToTarget->y = 0;
		$normalizedVector = $vectorToTarget->normalize();
		if(!$this->getWorld()->getBlock($this->location->addVector($normalizedVector)) instanceof Transparent){
			$this->jump();
		}else{
			$motion = $normalizedVector->multiply($this->getMovementSpeed());
			if(!$this->onGround){
				$motion = $motion->multiply(0.5);
			}
			$this->lastMotion->x = $motion->x;
			$this->lastMotion->z = $motion->z;
			$this->motion = clone $this->lastMotion;
		}

		$nearest = $this->getNearestEntityButSelf();
		if($nearest !== null){
			$boundingMotion = $nearest->getPosition()->subtractVector($this->location)->normalize()->multiply(-1);
			$this->addMotion($boundingMotion->x, 0, $boundingMotion->z);
		}

		return $update;
	}

	public function entityBaseTick(int $tickDiff = 1): bool{
		if($this->actionAttackTime > 0){
			$this->actionAttackTime -= $tickDiff;
			if($this->actionAttackTime < 0){
				$this->actionAttackTime = 0;
			}
		}

		if($this->searchTime > 0){
			$this->searchTime -= $tickDiff;
			if($this->searchTime < 0){
				$this->searchTime = 0;
			}
		}

		return parent::entityBaseTick($tickDiff);
	}

	public function attack(EntityDamageEvent $source): void{
		if($source instanceof EntityDamageByEntityEvent){
			$this->setTarget($source->getDamager());
		}
		parent::attack($source); // TODO: Change the autogenerated stub
	}

	abstract public function actionAttack(): void;

	private function getNearestEntityButSelf(): ?Entity{
		$world = $this->getWorld();
		$pos = $this->location;
		$maxDistance = $this->boundingRadius;
		$minX = ((int) floor($pos->x - $maxDistance)) >> Chunk::COORD_BIT_SIZE;
		$maxX = ((int) floor($pos->x + $maxDistance)) >> Chunk::COORD_BIT_SIZE;
		$minZ = ((int) floor($pos->z - $maxDistance)) >> Chunk::COORD_BIT_SIZE;
		$maxZ = ((int) floor($pos->z + $maxDistance)) >> Chunk::COORD_BIT_SIZE;

		$currentTargetDistSq = $maxDistance ** 2;

		/**
		 * @var Entity|null $currentTarget
		 * @phpstan-var TEntity|null $currentTarget
		 */
		$currentTarget = null;

		for($x = $minX; $x <= $maxX; ++$x){
			for($z = $minZ; $z <= $maxZ; ++$z){
				if(!$world->isChunkLoaded($x, $z)){
					continue;
				}
				foreach($world->getChunkEntities($x, $z) as $entity){
					if($entity === $this or !($entity instanceof Living) or $entity->isFlaggedForDespawn() or !$entity->isAlive()){
						continue;
					}
					$distSq = $entity->getPosition()->distanceSquared($pos);
					if($distSq < $currentTargetDistSq){
						$currentTargetDistSq = $distSq;
						$currentTarget = $entity;
					}
				}
			}
		}
		return $currentTarget;
	}

	protected function setTarget(?Entity $target){
		$this->target = $target;
	}

}